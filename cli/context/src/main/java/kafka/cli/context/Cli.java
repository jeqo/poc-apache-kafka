package kafka.cli.context;

import org.apache.kafka.clients.admin.AdminClient;
import picocli.CommandLine;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Properties;
import java.util.concurrent.Callable;

@CommandLine.Command(name = "kfk-ctx", versionProvider = Cli.VersionProviderWithConfigProvider.class, mixinStandardHelpOptions = true, subcommands = {
        Cli.Create.class,
        Cli.ConfigProperties.class }, descriptionHeading = "Kafka CLI - Context", description = "Manage Kafka connection properties as contexts.")
public class Cli implements Callable<Integer> {

    public static void main(String[] args) {
        int exitCode = new CommandLine(new Cli()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public Integer call() throws Exception {
        var contexts = Contexts.from(Files.readAllBytes(contextConfig()));
        System.out.println(contexts.names());
        return 0;
    }

    static void save(Contexts contexts) throws IOException {
        Files.write(contextConfig(), contexts.serialize());
    }

    static Path contextConfig() throws IOException {
        final Path home = baseDir();

        final var context = home.resolve("config");
        if (!Files.isRegularFile(context)) {
            System.err.println("Kafka Content configuration file doesn't exist, creating one...");
            Files.write(context, Contexts.empty());
        }

        return context;
    }

    private static Path baseDir() throws IOException {
        final var homePath = System.getProperty("user.home");
        if (homePath.isBlank())
            throw new IllegalStateException("Can't find user's home. ${HOME} is empty");

        final var home = Path.of(homePath, ".kafka");
        if (!Files.isDirectory(home)) {
            System.err.println("Kafka Context directory doesn't exist, creating one...");
            Files.createDirectories(home);
        }
        return home;
    }

    @CommandLine.Command(name = "create", description = "Register context. Destination: ~/.kafka/config")
    static class Create implements Callable<Integer> {

        @CommandLine.Parameters(index = "0", description = "Context name. e.g. `local`")
        String name;
        @CommandLine.Parameters(index = "1", description = "Kafka bootstrap servers. e.g. `localhost:9092`")
        String bootstrapServers;

        @CommandLine.Option(names = "--auth", description = "Authentication type (default: ${DEFAULT-VALUE}). Valid values: ${COMPLETION-CANDIDATES}", required = true, defaultValue = "PLAINTEXT")
        Contexts.KafkaAuth.AuthType authType;
        @CommandLine.Option(names = { "--username", "-u" }, description = "Username for SASL authentication")
        String username;
        @CommandLine.Option(names = { "--password", "-p" }, description = "Password for SASL authentication", arity = "0..1", interactive = true)
        String password;

        @Override
        public Integer call() throws Exception {
            var contexts = Contexts.from(Files.readAllBytes(contextConfig()));

            final Contexts.KafkaAuth auth;
            switch (authType) {
                case SASL_PLAIN -> auth = new Contexts.UsernamePasswordAuth(authType, username,
                        passwordHelper().encrypt(password));
                default -> auth = new Contexts.NoAuth();
            }
            final var ctx = new Contexts.Context(name, new Contexts.KafkaCluster(bootstrapServers, auth));

            contexts.add(ctx);
            save(contexts);

            System.out.printf("Context %s with bootstrap-servers %s saved.", ctx.name(),
                    ctx.cluster().bootstrapServers());
            return 0;
        }

    }

    static PasswordHelper passwordHelper() throws IOException {
        final var saltPath = baseDir().resolve(".salt");
        if (!Files.exists(saltPath)) {
            final var salt = PasswordHelper.generateKey();
            Files.writeString(saltPath, salt);
            return new PasswordHelper(salt);
        }
        else {
            final var salt = Files.readString(saltPath);
            return new PasswordHelper(salt);
        }
    }

    @CommandLine.Command(name = "properties", description = "Get properties configuration for context")
    static class ConfigProperties implements Callable<Integer> {

        @CommandLine.Parameters(index = "0", description = "Context name")
        String name;
        @CommandLine.Option(names = { "--test", "-t" }, description = "Test properties")
        boolean test;

        @Override
        public Integer call() throws Exception {
            var contexts = Contexts.from(Files.readAllBytes(contextConfig()));
            var ctx = contexts.get(name);
            final Properties props = ctx.properties(passwordHelper());
            props.store(System.out, "Generated by kfkctx");

            if (test) {
                try (final var admin = AdminClient.create(props)) {
                    final var clusterId = admin.describeCluster().clusterId().get();
                    System.err.printf("Connection to cluster %s succeed%n", clusterId);
                    admin.describeCluster().nodes().get().forEach(node -> System.err.println("Node: " + node));
                }
                catch (Exception e) {
                    System.err.println("Connection to cluster failed");
                    e.printStackTrace();
                    return 1;
                }
            }
            return 0;
        }

    }

    static class VersionProviderWithConfigProvider implements CommandLine.IVersionProvider {

        @Override
        public String[] getVersion() throws IOException {
            final var url = VersionProviderWithConfigProvider.class.getClassLoader().getResource("cli.properties");
            if (url == null) {
                return new String[]{ "No cli.properties file found in the classpath." };
            }
            final var properties = new Properties();
            properties.load(url.openStream());
            return new String[]{
                    properties.getProperty("appName") + " version " + properties.getProperty("appVersion") + "",
                    "Built: " + properties.getProperty("appBuildTime"), };
        }
    }

}
