package kafka.cli.context;

import org.apache.kafka.clients.admin.AdminClient;
import picocli.CommandLine;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Properties;
import java.util.concurrent.Callable;

@CommandLine.Command(name = "kfkctx", subcommands = {Cli.Create.class, Cli.ToProperties.class}) public class Cli
    implements Callable<Integer> {

    public static void main(String[] args) {
        int exitCode = new CommandLine(new Cli()).execute(args);
        System.exit(exitCode);
    }

    @Override public Integer call() throws Exception {
        var contexts = Contexts.from(Files.readAllBytes(contextConfig()));
        System.out.println(contexts.names());
        return 0;
    }

    static void save(Contexts contexts) throws IOException {
        Files.write(contextConfig(), contexts.serialize());
    }

    static Path contextConfig() throws IOException {
        final Path home = baseDir();

        final var context = home.resolve("config");
        if (!Files.isRegularFile(context)) {
            System.err.println("Kafka Content configuration file doesn't exist, creating one...");
            Files.write(context, Contexts.empty());
        }

        return context;
    }

    private static Path baseDir() throws IOException {
        final var homePath = System.getProperty("user.home");
        if (homePath.isBlank())
            throw new IllegalStateException("Can't find user's home. ${HOME} is empty");

        final var home = Path.of(homePath, ".kafka");
        if (!Files.isDirectory(home)) {
            System.err.println("Kafka Context directory doesn't exist, creating one...");
            Files.createDirectories(home);
        }
        return home;
    }

    @CommandLine.Command(name = "create", description = "Register context.") static class Create
        implements Callable<Integer> {

        @CommandLine.Parameters(index = "0", description = "Context name") String name;

        @CommandLine.Parameters(index = "1", description = "Kafka bootstrap servers") String
            bootstrapServers;

        @CommandLine.Option(names = {
            "--auth"}, description = "Authentication type", required = true, defaultValue = "PLAINTEXT")
        Contexts.KafkaAuth.AuthType authType;
        @CommandLine.Option(names = {"--username",
            "-u"}, description = "Username for SASL authentication") String username;
        @CommandLine.Option(names = {"--password",
            "-p"}, description = "Password for SASL authentication", arity = "0..1", interactive = true)
        String password;

        @Override public Integer call() throws Exception {
            var contexts = Contexts.from(Files.readAllBytes(contextConfig()));

            final Contexts.KafkaAuth auth;
            switch (authType) {
                case SASL_PLAIN -> auth = new Contexts.UsernamePasswordAuth(authType, username,
                    passwordHelper().encrypt(password));
                default -> auth = new Contexts.NoAuth();
            }
            final var ctx =
                new Contexts.Context(name, new Contexts.KafkaCluster(bootstrapServers, auth));

            contexts.add(ctx);
            save(contexts);

            System.out.printf("Context %s with bootstrap-servers %s saved.", ctx.name(),
                ctx.cluster().bootstrapServers());
            return 0;
        }

    }

    static PasswordHelper passwordHelper() throws IOException {
        final var saltPath = baseDir().resolve(".salt");
        if (!Files.exists(saltPath)) {
            final var salt = PasswordHelper.generateKey();
            Files.writeString(saltPath, salt);
            return new PasswordHelper(salt);
        } else {
            final var salt = Files.readString(saltPath);
            return new PasswordHelper(salt);
        }
    }


    @CommandLine.Command(name = "properties", description = "Get properties configuration for context")
    static class ToProperties implements Callable<Integer> {

        @CommandLine.Parameters(index = "0", description = "Context name") String name;
        @CommandLine.Option(names = {"--test",
            "-t"}, description = "Test properties") boolean test;

        @Override public Integer call() throws Exception {
            var contexts = Contexts.from(Files.readAllBytes(contextConfig()));
            var ctx = contexts.get(name);
            final Properties props = ctx.properties(passwordHelper());
            props.store(System.out, "Generated by kfkctx");

            if (test) {
                try (final var admin = AdminClient.create(props)) {
                    final var clusterId = admin.describeCluster().clusterId().get();
                    System.err.printf("Connection to cluster %s succeed%n", clusterId);
                    admin.describeCluster().nodes().get()
                        .forEach(node -> System.err.println("Node: " + node));
                } catch (Exception e) {
                    System.err.println("Connection to cluster failed");
                    e.printStackTrace();
                    return 1;
                }
            }
            return 0;
        }

    }

}
